{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww13380\viewh17840\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\i\fs24 \cf0 En cours perfectionnement dans la pratique des Promises, la question s'est pos\'e9e de leur application lors du passage d'un objet en param\'e8tre d'une fonction.
\i0 \
\
Cette fonction initialise en effet un autre objet \'e0 partir de son argument, et il y doit y avoir dans cet objet \'e0 construire des valeurs de propri\'e9t\'e9s d\'e9pendant d'autres propri\'e9t\'e9s.\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b \cf0 It\'e9ration de propri\'e9t\'e9s dans le d\'e9sordre et d\'e9pendance de certaines ?
\b0 \
\
L'initialisation s'effectuant via une boucle for\'85in, l'ordre d'it\'e9ration des propri\'e9t\'e9s de l'argument reste arbitraire. L'ordre des propri\'e9t\'e9s lors du param\'e9trage du l'objet initial, ne garantit donc aucun r\'e9sultat. Une propri\'e9t\'e9 d\'e9pendant d'une autre a des risques d'\'eatre initialis\'e9e avant celle-ci.\
\
Une solution fond\'e9e sur les Promises assure le respect de ces contraintes :\
- passage d'un objet comme param\'e8tre d'une fonction ;\
- traitement des propri\'e9t\'e9s de cet objet sans ordre a priori ;\
- initialisation par l\'e0 d'un objet ayant les m\'eame cl\'e9s et dont certaines propri\'e9t\'e9s d\'e9pendent des autres.\
\
Passage d'un objet comme param\'e8tre :\
\
selection.setProperties(\{\
	trois: selection.checkProperty("trois"),\
	deux: selection.checkProperty("deux"),\
	un: selection.checkProperty("un")\
\});\
\
Traitement sans ordre a priori :\
\
for (var k in o)\
	(selection[k] = o[k]);\
\
Dont certaines propri\'e9t\'e9s d\'e9pendent des autres :\
\
selection.calcul.trois = function () \{\
	return selection.deux ? selection.deux + "3" : false;\
\}\
\
\

\b Une solution avec les Pomises
\b0 \
\
Dans l'objet en param\'e8tre, les zones imparties aux valeurs ex\'e9cutent une fonction qui, si c'est possible, retourne une valeur - si les propri\'e9t\'e9s qui la conditionnent existent d\'e9j\'e0 - ou bien qui se termine sur une Promise cha\'een\'e9e.\
\
En ce cas, l'affectation de la valeur est report\'e9e et aura lieu quand une premi\'e8re mouture de l'objet final aura \'e9t\'e9 produite. Dans celle-ci, seules sont affect\'e9es les valeurs qui n'ont pas besoin d'autres propri\'e9t\'e9s, ou pour lesquelles les propri\'e9t\'e9s n\'e9cessaires ont d\'e9j\'e0 \'e9t\'e9 trait\'e9es.\
\
Cette mouture est produite dans le cadre d'une premi\'e8re Promise, auxquelles viennent ainsi se cha\'eener les affectation probl\'e9matiques.\
(Si les affectations probl\'e9matiques pr\'e9c\'e8dent l'instanciation de la premi\'e8re Promise, elles sont cha\'een\'e9es \'e0 une Promise inexistante, ce qui semble sans incidence - \'e9galement en cas de fort volume de donn\'e9es ?)\
\
Ces cha\'eenages conditionnels sont r\'e9alis\'e9s par la m\'e9thode Promise.resolve(), et permettent d'appeler de nouveau la fonction initiale, avec cette fois-ci comme param\'e8tre un objet r\'e9duit \'e0 la paire cl\'e9/valeur probl\'e9matique.\
\
\

\b Exemple
\b0 \
\
Dans mon exemple, l'objet a trois propri\'e9t\'e9s, "trois", "deux", "un".\
Sur les trois propri\'e9t\'e9s de l'objet "selection" \'e0 obtenir, la valeur de l'une ("123") d\'e9pend d'une autre ("12") qui d\'e9pend d'une autre ("1").\
Lorsque la valeur ind\'e9pendante "1" est trait\'e9e, la Promise initiale est instanci\'e9e. \'c0 celle-ci vient se cha\'eener les Promises de calcul des deux valeurs d\'e9pendantes.\
\
var selection = \{\
	setProperties: function (o) \{\
		selection.p = new Promise(function (r) \{\
			for (var k in o)\
				(selection[k] = o[k]);\
			r();\
		\});\
	\},\
	checkProperty: function (ope) \{\
		var test = selection.calcul[ope]();\
		if (test)\
			return test;\
		else \{\
			selection.P.push(Promise.resolve(selection.p).then(function () \{\
				selection.setProperties(\{\
					[ope]: selection.checkProperty(ope)\
				\});\
			\}));\
		\}\
	\},\
	calcul: \{\},\
	P: []\
\};\
\
/* ---- */\
\
selection.calcul.trois = function () \{\
	return selection.deux ? selection.deux + "3" : false;\
\}\
selection.calcul.deux = function () \{\
	return selection.un ? selection.un + "2" : false;\
\}\
selection.calcul.un = function () \{\
	return "1";\
\}\
selection.setProperties(\{\
	trois: selection.checkProperty("trois"),\
	deux: selection.checkProperty("deux"),\
	un: selection.checkProperty("un")\
\});\
\
Promise.resolve(selection.P[selection.P.length - 1]).then(function()\{\
	for (var k in selection)\
		console.log(k, selection[k])\
	console.log(selection["deux"], selection);\
\});\
\
Entre le param\'e9trage de la fonction "setProperties" et son ex\'e9cution, se trouve la fonction interm\'e9diaire g\'e9n\'e9rique "checkProperty" qui sert soit \'e0 produire une valeur destin\'e9e \'e0 l'\'e9x\'e9cution finale - en faisant appel aux m\'e9thodes personnelles "selection.calcul" - soit, si ce n'est pas encore possible, une Promise cha\'een\'e9e o\'f9 la fonction "setProperties" sera reparam\'e9tr\'e9e.\
De l\'e0, nouveaux passages par "checkProperty" et "selection.calcul" autant de fois que n\'e9cessaire, jusqu'\'e0 ce que toutes les propri\'e9t\'e9s qui basent le calcul ait \'e9t\'e9 affect\'e9es.\
\
Il est temps d'orienter ma curiosit\'e9 vers d'autres solutions.}