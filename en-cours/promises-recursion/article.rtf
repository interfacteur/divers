{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf400
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww12900\viewh17200\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\b\fs28 \cf0 Promesses et r\'e9cursivit\'e9 : ordonnancer des promesses simultan\'e9es
\b0\fs24 \
\
Lorsqu'on lance un groupe de promesses simultan\'e9es avec la m\'e9thode Promise.all(), l'on peut lier une instruction finale \'e0 leur accomplissement.\
\
Quand certaines de ces promesses d\'e9pendent des autres pour atteindre un objectif, d\'e9finir un objet par exemple, il est utile d'en relancer certaines instructions avant l'instruction finale. L'enjeu est alors de relancer ou d'enrichir la promesse it\'e9rative ".all()", \'e0 laquelle l'instruction finale est li\'e9e.\
\
\'c0 noter, cette question n'est pas la m\'eame que le maintien de l'ordre d'instanciation d'un flux de promesses au fur et \'e0 mesure qu'elles se tiennent (1).\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\i \cf0 \
(1) Cf. HTML5 Rocks : <a href="http://www.html5rocks.com/fr/tutorials/es6/promises">JavaScript Promises: There and back again</a><br>\
et <a href="http://www.equatorium.net/e1/ex--exemples/promise-map-reduce.html">Promesses : map().reduce() \\ Bambous ~ exemples / Equatorium</a>\

\i0 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\b \cf0 Vu sous l'angle des facteurs
\b0 \
\
Imaginons les cinq promesses simultan\'e9es "2", "3", "4", "6" et "8". Toutes seraient tenues formellement \'e0 l'issue du flux initial, mais toutes n'atteindraient pas leur objectif - d\'e9finir les propri\'e9t\'e9s d'un objet.\
L'objectif des deux premi\'e8res serait toujours atteint, ind\'e9pendamment du contexte. Pour que l'objectif de la "4" le soit, il faudrait que celui de la promesse "2" l'ait d\'e9j\'e0 \'e9t\'e9. Pour la "6", les objectifs de la "2" et de la "3". Pour la "8", de la "4" directement, et indirectement de la "2".\
Trois promesses se trouvent ainsi en d\'e9pendance, directe ou indirecte, de l'objectif de la promesse "2".\
\
Ces promesses de base composent l'argument it\'e9ratif de ".all()".\
\
Que le traitement ait lieu via des requ\'eates XMLHttpRequest ou en parcourant un objet (la nomenclature des cl\'e9s ne garantit pas l'ordre d'it\'e9ration), il est difficile de pr\'e9voir par exemple que la promesse du "2" sera "fulfilled" avant celle du "4".\
\

\b R\'e9cursion
\b0 \
\
Apr\'e8s l'accomplissement des promesses de base, certains objectifs sont tenus : au moins ceux de la "2" et de la "3". Pour les autres, tant qu'il en reste \'e0 atteindre, la solution est de relancer la fonction qui retourne la promesse initiale, ou qui lui est li\'e9e par la m\'e9thode ".then()".\
\

\b\fs20 Relancer la promesse initiale
\b0\fs24 \
\
Une possibilit\'e9 : la fonction s'invoque elle-m\'eame comme argument de la m\'e9thode "then()" li\'e9e directement \'e0 la promesse initiale qu'elle retourne :\
\
var promRecursive = function () \{\
	if (\'85) \{\
		return Promise.all(\
			datas.map(function (value, ind) \{\
				return new Promise(function (resolve) \{ \'85 \});\
			\})\
		)\
		.then(promRecursive); //la fonction s'invoque elle-m\'eame comme argument\
	\}\
\}\
\
promRecursive() //promesse initiale et r\'e9cursive\
.then(function () \{ //instruction finale\
	(\'85)\
\});\
\
Illustration : \
\
Ou, plus proche de notre exemple num\'e9rique :\
\
var promRecursive = function () \{\
	if (datas.proxy.length > 0) \{\
		return Promise.all(\
			datas.proxy.map(function (values, ind) \{ \'85 \})\
		)\
		.then(promRecursive); //la fonction s'invoque elle-m\'eame comme argument\
	\}\
\};\
\
Illustration : \
\

\b\fs20 Relancer des instructions en lien avec la promesse initiale
\b0\fs24 \
\
Apr\'e8s la premi\'e8re it\'e9ration, dans la plupart des cas, les instructions peuvent d\'e9sormais \'eatre ex\'e9cut\'e9es de mani\'e8re synchrone, sans recours aux promesses. Des donn\'e9es n'ont pas vocation \'e0 \'eatre t\'e9l\'e9charg\'e9es plusieurs fois \'e0 la suite. L'invocation est alors simplement r\'e9cursive :\
\
promRecursive = function () \{\
	if (datas.proxy.length == 5) \{ //premi\'e8re it\'e9ration\
		return Promise.all(\
			datas.proxy.map(function (values, ind) \{ \'85 \})\
		)\
		.then(promRecursive); //la fonction s'invoque elle-m\'eame comme argument\
	\}\
	else if (datas.proxy.length > 0) \{ //it\'e9rations suivantes tant qu'il reste des objectifs \'e0 atteindre\
		datas.proxy.forEach(function (values, ind) \{ \'85 \});\
		promRecursive(); //par r\'e9cursion\
	\}\
\};\
\
Dans ce cas, la promesse initiale est prolong\'e9e d'abord en se liant \'e0 elle-m\'eame, puis de mani\'e8re r\'e9cursive dans le cadre de ".then()" - jusqu'\'e0 ce que tous les objectifs des promesses de base soient atteints - laissant \'e9voluer les conditions afin que toutes soient r\'e9unies pour l'objectif qu'elles contraignent le plus.\
\
Illustration : \
\
Comme les r\'e9cursions \'e0 partir de la deuxi\'e8me s'ex\'e9cutent dans le cadre de "then()", elles sont encore 
\b encadr\'e9es par une promesse
\b0  li\'e9e \'e0 la promesse initiale : 
\b ".all(promesses de base).then(r\'e9cursion d'instruction simples)",
\b0  \'e0 laquelle l'instruction finale reste synchronis\'e9e.\
\
Notons que cela marche aussi bien avec deux fonctions au lieu de deux conditions :\
\
promInit = function () \{\
	return Promise.all(\
		datas.proxy.map(function (values, ind) \{ \'85 \})\
	)\
\},\
promRecursive = function () \{\
	if (datas.proxy.length > 0) \{\
		datas.proxy.forEach(function (values, ind) \{ \'85 \});\
		return promRecursive();\
	\}\
\};\
\
promInit()\
.then(promRecursive)\
.then(function () \{ //instruction finale\
	(\'85)\
\});\
\
Illustration : \
\

\b Coordination progressive
\b0 \
\
Ainsi, la promesse initiale est prolong\'e9e jusqu'\'e0 ce que tous les objectifs des promesses de base soient atteints. L'instruction finale se trouve alors de fait li\'e9e \'e0 une promesse initiale enrichie.\
\
La r\'e9cursivit\'e9 laisse s'\'e9tablir progressivement une coordination dans le r\'e9sultat du flux de la promesse initiale ".all()".\
\
Une fois r\'e9duit \'e0 z\'e9ro le nombre d'objectifs \'e0 atteindre (l'objet datas.proxy dans notre exemple), elle se conclut. C'est \'e0 ce moment que l'instruction finale est ex\'e9cut\'e9e :\
\
promRecursive()\
.then(function () \{ //instruction finale\
	(\'85)\
\});\
\
Dans notre exemple, chaque promesse est renseign\'e9e sur celles dont elle d\'e9pend, ou bien n'est soumise qu'\'e0 une seule g\'e9n\'e9ration de d\'e9pendance induite - par exemple la "8" avec la d\'e9pendance "2". Avec un grand nombre de g\'e9n\'e9rations induites, cela fonctionne tout aussi bien.\
\
Illustration : \
\
Il est donc ais\'e9 de coordonner, via un aiguillage r\'e9cursif, les r\'e9sultats d'un flux de promesses simultan\'e9es.\
\
}